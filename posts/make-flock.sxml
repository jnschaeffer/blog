(use-modules (srfi srfi-19))

(define post
  `((p
      "I've had the privilege of working recently on a Go project that uses code generation and Make together - knowing very little about the former and essentially nothing about the latter, I thought I would try breaking up some of the codegen work and speed up the build process for this project. This went about as well as you might expect for brand-new toolchains and software that dates back to the 1970s, which is to say not very.")
    (h2 (@ (id "problem")) (a (@ (href "#problem")) "The problem"))
    (p
     "The actual problem I ran into, once removed from the context of a lot of in-house tooling and domain-specific constraints, was pretty simple: a project had some build steps with generated files as dependencies, and several of those files were generated by invoking two shell commands. These commands take a few seconds to run on average, and will always generate all of the necessary files in a single invocation, so calling them once and only when necessary was the desired behavior.")
    (p
     "Two issues arose from this. The first, which seemed to not be a major impediment to the task at hand, was that the set of generated files wasn't known in advance. In general, "
     (a (@ (href "https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html")) "Make targets are expected to be file names")
     ", which means that if you don't know the names of the files you're generating, writing rules for those files is hard. To get around this, I naively hardcoded the names of the files that the generator programs were creating into the Makefile. At this point my Makefile looked a little bit like this:")
    (pre "THINGS := a.go b.go c.go

$(THINGS):
	echo \"compiling $@\" && sleep 3 && touch $(THINGS)

.PHONY: things
things: $(THINGS)
")
    (p
     "Running "
     (code "make things")
     " has the desired effect in this case; the command is invoked once for "
     (code "a.go")
     " and subsequent targets are ignored because they have already been created. Running "
     (code "make -j8 things")
     ", however, produced very different results:")
    (pre "$ make -j8 things
echo \"compiling a.go\" && sleep 3 && touch a.go b.go c.go
echo \"compiling b.go\" && sleep 3 && touch a.go b.go c.go
echo \"compiling c.go"" && sleep 3 && touch a.go b.go c.go
compiling a.go
compiling b.go
compiling c.go
$")
    (p
     "The second issue, as anyone who knows how Make works (i.e. not me) could tell you, was that Make rules assume not just that a target is a file name, but that there is a one-to-one correspondence between targets and recipes, which means a recipe is used to generate a single file from a set of prerequisites. Thus, once I modified my Makefile rules to explicitly list each generated target file in the same rule, Make helpfully began running the code generation commands once for each file. This was obviously incorrect; what was less obvious was an approach that would actually work.")
    (h2 (@ (id "official-solution")) (a (@ (href "#official-solution")) "The official solution"))
    (p
     "Usually, when I run into problems like this I like to consult official documentation. Maintainers see their tools get used and abused in all kinds of ways, and the documentation they provide on how to use their own tools is a good starting point for most tasks. In this case, it was also almost completely useless.")
    (p
     "The documentation for Make does not cover the use case of recipes generating multiple target files at all. It does cover the general case of multiple targets for a single rule "
     (a (@ (href "https://www.gnu.org/software/make/manual/html_node/Multiple-Targets.html")) "here")
     ", though, and explicitly states that a rule with multiple targets is equivalent to multiple rules that each generate a single target with the same recipe. While unfortunate in my particular scenario, what I was seeing was at least expected behavior.")
    (p
     "What did provide some guidance was the documentation for Automake. "
     (a (@ (href "https://www.gnu.org/software/automake/manual/html_node/Multiple-Outputs.html")) "The official solution")
     ", such as it is, is to create lock and timestamp files to keep the build mostly synchronized. If you don't feel like reading the full document, this is the pasted example of how to manage multiple outputs for a single rule:")
    (pre
     "ELFILES = one.el two.el three.el â€¦
ELCFILES = $(ELFILES:=c)

elc-stamp: $(ELFILES)
        @rm -f elc-temp
        @touch elc-temp
        $(elisp_comp) $(ELFILES)
        @mv -f elc-temp $@

$(ELCFILES): elc-stamp
## Recover from the removal of $@
        @dry=; for f in x $$MAKEFLAGS; do
          case $$f in 
            *=*|--*);; 
            *n*) dry=:;; 
          esac; 
        done; 
        if test -f $@; then :; else 
          $$dry trap 'rm -rf elc-lock elc-stamp' 1 2 13 15; 
          if $$dry mkdir elc-lock 2>/dev/null; then 
## This code is being executed by the first process.
            $$dry rm -f elc-stamp; 
            $(MAKE) $(AM_MAKEFLAGS) elc-stamp; 
            $$dry rmdir elc-lock; 
          else 
## This code is being executed by the follower processes.
## Wait until the first process is done.
            while test -d elc-lock && test -z \"$$dry\"; do 
              sleep 1; 
            done; 
## Succeed if and only if the first process succeeded.
            $$dry test -f elc-stamp; exit $$?; 
          fi; 
        fi
")
    (p
     "This wasn't really a viable approach in my case, for a number of reasons (the most obvious being the sheer difficulty of following the code). Synchronization in programs is hard, but it's not 23-lines-of-shell-in-Makefiles hard.")
    (h2 (@ (id "flock-solution")) (a (@ (href "#flock-solution")) "One solution: use " (code "flock")))
    (p
     "After ruminating on this for a while, a more obvious solution did emerge: lock files. Lock files are used by all kinds of programs for inter-process synchronization, and controlling jobs in Make is (probably) no exception. Using "
     (code "flock")
     " and "
     (code "mktemp -u")
     ", the Makefile looks something like this:")
    (pre "THINGS := a.go b.go c.go
THING_LOCK := $(shell mktemp -u /tmp/thingXXX.lock)

$(THINGS):
	flock -nF -E 0 $(THING_LOCK) -c 'echo \"compiling $@\" && sleep 3 && touch $(THINGS) && rm $(THING_LOCK)'

.PHONY: things
things: $(THINGS)
")
    (p
     "The "
     (code "flock")
     " command line arguments are as follows: "
     (code "-n")
     " starts the process in non-blocking mode (i.e. it fails if it can't immediately take a lock); "
     (code "-F")
     " replaces the "
     (code "flock")
     " process with the child process instead of forking because we remove the lock at the end of the command; "
     (code "-E")
     " instructs "
     (code "flock")
     " to exit with an exit code of 0 if it can't get a lock, since in this case that's not an error; and "
     (code "-c")
     " indicates the command that should be run after the lock is taken.")
    (p
     "When running "
     (code "make -j8 things")
     " this time, the output looks more like what we might want:")
    (pre "$ make -j8 things
flock -nF -E 0 /tmp/thinguov.lock -c 'echo \"compiling a.go\" && sleep 3 && touch a.go b.go c.go && rm /tmp/thinguov.lock'
flock -nF -E 0 /tmp/thinguov.lock -c 'echo \"compiling b.go\" && sleep 3 && touch a.go b.go c.go && rm /tmp/thinguov.lock'
flock -nF -E 0 /tmp/thinguov.lock -c 'echo \"compiling c.go\" && sleep 3 && touch a.go b.go c.go && rm /tmp/thinguov.lock'
compiling a.go
$")
    (p
     "The main disadvantage to this approach is that it requires "
     (code "flock")
     ", which is a Linux command. If you're using another operating system, or just don't have "
     (code "flock")
     " available, keep reading.")
    (h2 (@ (id "setc-solution")) (a (@ (href "#setc-solution")) "Another solution: use " (code "set -C")))
    (p
     "As an alternative, "
     (code "set -C")
     " can be used to place the shell in a mode where it will not overwrite existing files, which provides a mostly-effective synchronization mechanism. This approach works on both Linux and macOS, though at the expense of some readability. A Makefile written with this approach might look something like this:")
    (pre "THINGS := a.go b.go c.go
THING_LOCK := $(shell mktemp -u /tmp/thingXXX.lock)

$(THINGS):
	(set -C && echo > $(THING_LOCK)) 2>/dev/null; \\
	if [ $$? -eq 0 ]; then \\
		echo \"compiling $@\" && sleep 3 && touch $(THINGS); \\
		rm $(THING_LOCK); \\
	fi

.PHONY: things
things: $(THINGS)
")
    (p
     "This uses a subshell with the "
     (code "-C")
     " option enabled to attempt to write to the lock file at "
     (code "$(THING_LOCK)")
     ". If it succeeds, the rest of the recipe will be executed and the lock file will be removed. Otherwise, the recipe is effectively a no-op ("
     (code "2>/dev/null")
     " is used here to prevent unnecessary shell output for recipes that do not successfully take a lock).")
    (h2 (@ (id "lessons")) (a (@ (href "#lessons")) "Lessons learned"))
    (p
     "Prior to this exercise, I had no real experience with writing Makefiles or using shell options to pull off any cool tricks. Getting Make to work with tools that don't enforce any relationship between source files and generated/compiled output was more difficult than I had expected, but I'd like to think the approaches here are decent.")))

`((title . "Makefiles and multiple build outputs")
  (date . ,(string->date "2019-09-18" "~Y-~m~d"))
  (summary . "An approach to writing Makefile rules for tools that produce many output files. Goes well with code generation.")
  (content ,post))
